from zarrnii import ZarrNii
import numpy as np
from lib.utils import * 


configfile: 'config.yml'

gridx=config['gridx']
gridy=config['gridy']

wildcard_constraints:
    tile='[0-9]+'


rule all:
    input: 
        'results/fused_SPIM.nii'

rule create_test_dataset_single_ome_zarr:
    params:
        grid_shape=(gridx,gridy),
        tile_index=lambda wildcards: int(wildcards.tile)
    output: 
        ome_zarr=directory('results/tile-{tile}_SPIM.ome.zarr'),
        nifti='results/tile-{tile}_SPIM.nii',
        nifti_fromzarr='results/tile-{tile}_fromzarr_SPIM.nii',
    script: 'scripts/create_test_dataset_singletile.py'


rule find_overlapping_pairs:
    input:
        ome_zarr=expand('results/tile-{tile}_SPIM.ome.zarr', tile=range(gridx*gridy)),
    output:
        txt='results/overlapping_pairs.txt'
    script: 'scripts/find_overlapping_pairs.py'
        
rule compute_pairwise_correlation:
    input:
        ome_zarr=expand('results/tile-{tile}_SPIM.ome.zarr', tile=range(gridx*gridy)),
        pairs='results/overlapping_pairs.txt'
    output:
        offsets='results/pairwise_offsets.txt',
        diagnostics_dir=directory('results/pairwise_offsets_work')
    script: 'scripts/compute_pairwise_correlation.py'

rule global_optimization:
    input:
        ome_zarr=expand('results/tile-{tile}_SPIM.ome.zarr', tile=range(gridx*gridy)),
        pairs='results/overlapping_pairs.txt',
        offsets='results/pairwise_offsets.txt'
    output:
        optimized_translations='results/optimized_translations.txt'
    script: 
        'scripts/global_optimization.py'
 

rule assign_translations:
    input:
        ome_zarr=expand('results/tile-{tile}_SPIM.ome.zarr', tile=range(gridx*gridy)),
        optimized_translations='results/optimized_translations.txt'
    output:
        nifti=expand('results/tile-{tile}_optimized_SPIM.nii', tile=range(gridx*gridy))
    script: 
        "scripts/assign_translation.py"

rule fuse_volume:
    input:
        ome_zarr=expand('results/tile-{tile}_SPIM.ome.zarr', tile=range(gridx*gridy)),
        #optimized_translations='results/optimized_translations.txt'
    output:
        ome_zarr = directory('results/fused_SPIM.ome.zarr'),
        nifti = 'results/fused_SPIM.nii'
    script: 
        'scripts/fuse_volume.py'



rule test_rtree_index:
    output:
        'results/tests/rtree_index.touch'
    shadow: 'minimal'
    run:

        paths = ["tile1.ome.zarr", "tile2.ome.zarr"]
        znimg1 = ZarrNii.from_darr(np.ones((1,8, 8, 8)), affine=-1*np.eye(4))
        znimg2 = ZarrNii.from_darr(np.ones((1,8, 8, 8)), affine=np.eye(4) * 2)
        
        znimg1.to_ome_zarr(paths[0])
        znimg2.to_ome_zarr(paths[1])

        idx, znimgs = build_rtree_index(paths)
        print("Index built successfully.")
        for entry in idx.intersection((-16, -16, -16, 0, 0, 0), objects=True):
            print("Intersecting object:", entry.object)
        shell('touch {output}')


rule test_process_block_single:
    input:
        niftis=expand('results/tile-{i}_SPIM.nii',i=range(4))
    output:
        flag='results/tests/process_block_single.touch',
        fused='results/tests/fused_test.nii'
    shadow: 'minimal'
    run:
        # Mock tile data
        for i,nii in enumerate(input.niftis):
            ZarrNii.from_nifti(nii).to_ome_zarr(f'test_tile_{i}.ome.zarr')
            

        # Create a mock R-tree index
        idx, znimgs = build_rtree_index([f'test_tile_{i}.ome.zarr' for i in range(len(input.niftis))])
        

        # Mock block info
        block_data = np.zeros((128, 128, 128), dtype=np.float32)
        block_info = [{"chunk-location": (0, 0, 0)}]
        
        # Call process_block
        result = process_block(
            block_data,
            block_info=block_info,
            rtree_idx=idx,
            znimgs=znimgs,
            global_bbox_min=np.zeros(3),
            target_voxel_spacing=np.ones(3)
        )

        print("Processed block result:", result)
        print(result.shape)
        ZarrNii.from_array(result.reshape(1,128,128,128),axes_order=znimgs[0].axes_order,orientation=znimgs[0].get_orientation()).to_nifti(output.fused)
        shell('touch {output.flag}')

rule test_process_block_multi:
    input:
        niftis=expand('results/tile-{i}_SPIM.nii',i=range(4))
    output:
        flag='results/tests/process_block_multi.touch',
        fused='results/tests/fused_test_multi.nii'
    shadow: 'minimal'
    run:
        # Mock tile data
        for i,nii in enumerate(input.niftis):
            ZarrNii.from_nifti(nii).to_ome_zarr(f'test_tile_{i}.ome.zarr')
            

        # Create a mock R-tree index
        idx, znimgs = build_rtree_index([f'test_tile_{i}.ome.zarr' for i in range(len(input.niftis))])
        

        output_shape=(200,200,200)
        output_chunks=(100,100,100)
        fused_dask_array = da.zeros(output_shape, chunks=output_chunks, dtype=np.float32)
        znimg_fused = ZarrNii.from_darr(fused_dask_array,
                                             axes_order=znimgs[0].axes_order,
                                             orientation=znimgs[0].get_orientation(),
                                             spacing=(0.5,0.5,0.5),
                                             origin=(0,0,0))

        # Apply map_blocks to process the fused array --- could consider putting this into zarrnii as a member function.. 
        processed_dask_array = znimg_fused.darr.map_blocks(
            process_block,
            dtype=np.float32,
            rtree_idx=idx,
            znimgs=znimgs,
            affine=znimg_fused.affine,
        )

        znimg_fused.darr = processed_dask_array.reshape(1,output_shape[0],output_shape[1],output_shape[2])
        znimg_fused.to_nifti(output.fused)

        #print(processed_dask_array.shape)
        #ZarrNii.from_darr(processed_dask_array.reshape(1,output_shape[0],output_shape[1],output_shape[2]),axes_order=znimgs[0].axes_order,orientation=znimgs[0].get_orientation()).to_nifti(output.fused)
        shell('touch {output.flag}')


rule test_resample_chunk_to_block:
    output:
        'results/tests/resample_chunk_to_block.touch'
    shadow: 'minimal'
    run:
        # Mock chunk data
        chunk_data = np.arange(27).reshape(3, 3, 3)
        chunk_bbox_min = np.array([0, 0, 0])
        chunk_bbox_max = np.array([4, 4, 4])
        block_bbox_min = np.array([0, 0, 0])
        block_bbox_max = np.array([4, 4, 8])
        block_shape = (3, 3, 3)
        print(f'chunk_data: {chunk_data}')
        print(f'chunk_bbox_min: {chunk_bbox_min}')
        print(f'chunk_bbox_max: {chunk_bbox_max}')
        print(f'block_bbox_min: {block_bbox_min}')
        print(f'block_bbox_max: {block_bbox_max}')

        # Resample the chunk
        resampled = resample_chunk_to_block_alt1(chunk_data, chunk_bbox_min, chunk_bbox_max, block_bbox_min, block_bbox_max, block_shape)
        print("Resampled data:", resampled)
        shell('touch {output}')
